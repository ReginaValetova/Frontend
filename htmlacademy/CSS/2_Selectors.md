# Селекторы

## Селекторы по тегам

Задавать атрибут __style__ для каждого тега неудобно и долго. Особенно, если тот же результат можно получить с помощью единственного CSS-правила, в котором используется селектор для тега __li__.

С помощью селекторов по именам тегов можно задать стили для всех элементов списка, изображений, абзацев и так далее. Эти селекторы содержат имя тега без символов **<** и **>**. Например:

```css
li {
  /* стили для элементов списка */
}
```

## Селекторы по классам

Класс — это один из атрибутов тегов. Выглядит он вот так:

```css
<li class="first"></li>
```
Этот атрибут особенный, так как в CSS существует возможность выбирать элементы по классу. Делается это с помощью такого селектора: __.имя_класса__. Например:
```css
.first {
  /* стили для класса first */
}
```
## Контекстные селекторы

Селектор может состоять из нескольких частей, разделённых пробелом, например:

```css
p strong { ... }
ul .hit { ... }
.footer .menu a { ... }
```

Такие селекторы называют контекстными или вложенными. Их используют для того, чтобы применить стили к элементу, только если он вложен в нужный элемент.

Например, селектор __.menu__ a сработает для ссылки __a__ только в том случае, если она расположена внутри элемента с классом __.menu__.

Читать их проще всего справа налево:

```css
/* выбрать все теги strong внутри тегов p */
p strong { ... }

/* выбрать все элементы с классом .hit внутри тегов ul */
ul .hit { ... }

/* выбрать все ссылки внутри элементов с классом .menu,
   которые лежат внутри элементов с классом .footer */
.footer .menu a { ... }

```

Таким образом, можно задавать элементам различные стили в зависимости от их контекста. Если ссылка расположена внутри меню, сделать её крупнее, а если внутри основного текста, то задать ей нужный цвет.

## Соседние селекторы

Контекстные селекторы используются для вложенных друг в друга элементов, а соседние — для расположенных рядом.

Например, теги __'li'__ в списке являются соседними по отношению друг к другу и вложенными в тег __'ul'__.

Соседние селекторы записываются с помощью знака __+__, например, __селектор1 + селектор2__. Стили применятся к элементу, подходящему под __селектор2__, только если сразу перед ним расположен элемент, подходящий под __селектор1__.

Пример. Есть два элемента списка:
```css
<li class="hit"></li>
<li class="miss"></li>
```
Селектор __.hit + .miss__ применит стили к элементу с классом __miss__, так как перед ним есть элемент с классом __hit__.

Селектор __.hit + li__ тоже применит стили к элементу с классом __miss__, а селектор __.miss + .hit__ не сработает.

## Дочерние селекторы

Потомком называются любые элементы, расположенные внутри родительского элемента. А дочерними элементами называются ближайшие потомки. Взгляните на пример:

```css
<ul>
  <li><span> ... </span></li>
  <li><span> ... </span></li>
</ul>
```
По отношению к __'ul' 'li'__ являются дочерними элементами и потомками, а __'span'__ — потомки, но не дочерние элементы.

Контекстные селекторы влияют на всех потомков, что не всегда удобно. Иногда необходимо задать стили только для дочерних элементов. Особенно это полезно при работе с многоуровневыми списками.

Для этого существует дочерний селектор, в котором используется символ >. Например: __ul > li__ или __ul > li > span__.

## Псевдоклассы

Псевдоклассы — это дополнения к обычным селекторам, которые делают их ещё точнее и мощнее. Обычный селектор — это снайперский прицел, а с псевдоклассом он становится прибором ночного видения.

Псевдокласс добавляется к селектору c помощью символа __:__, вот так __селектор:псевдокласс__. Например:
```css
a:visited { ... }
li:last-child { ... }
.alert:hover { ... }
```

Знакомство с псевдоклассами мы начнём с __first-child__ и __last-child__.

Псевдокласс __first-child__ позволяет выбрать первый дочерний элемент родителя, а __last-child__ — последний дочерний элемент. Например:

```css
li:last-child { ... }
```
Этот селектор выберет последний элемент списка.

## Псевдокласс :nth-child

С помощью псевдокласса __nth-child__ можно выбирать теги по порядковому номеру, не используя классы. Синтаксис псевдокласса: __селектор:nth-child__(выражение). Выражением может быть число или формула. Например:

```css
1. li:nth-child(2) { ... }
2. li:nth-child(4) { ... }
3. li:nth-child(2n) { ... }
```
Первый селектор выберет второй элемент списка, второй селектор — четвёртый элемент списка, третий селектор — все чётные элемент

## Псевдокласс :hover

Некоторые псевдоклассы позволяют выбирать элементы, с которыми взаимодействует пользователь. Сначала познакомимся с псевдоклассом __:hover__.

Этот псевдокласс позволяет выбрать элемент, когда на него наведён курсор мыши и кнопка мыши не нажата. Примеры:
```css
1. a:hover { ... }
2. tr:hover { ... }
3 .menu-item:hover { ... }
```

Первый селектор выбирает ссылку, второй строку таблицы, третий элемент с классом __menu-item__, но только в том случае, если на них наведён курсор мыши.

Благодаря этому псевдоклассу можно добавлять в интерфейс динамику и интерактивность, так как элементы начинают реагировать на действия пользователя, изменяя свой внешний вид.


## Динамические эффекты с помощью :hover

Интересовались ли вы, как с помощью CSS создаются выпадающие меню?

Львиная доля динамических эффектов, создаваемых с помощью CSS, опираются на несколько псевдоклассов, главный из которых, конечно же, __:hover__. Весь секрет заключается в сочетании контекстных селекторов и псевдоклассов. Посмотрите на пример:

```css
li.top ul.submenu {
  display: none;
}

li.top:hover ul.submenu {
  display: block;
}
```

Первое правило прячет список-подменю. Второе правило гласит: «если на верхний пункт меню, в котором находится подменю, наведут курсор, то надо показать подменю». Вот так всё просто.

Общий принцип такой: родительский элемент реагирует на наведение мыши и изменяет свойства элементов-потомков. То есть всё работает на контекстных селекторах вида __селектор1:hover селектор2__.

## Псевдоклассы :link, :visited и :active

Познакомимся с псевдоклассами для ссылок.

* :link выбирает ещё не посещённые ссылки.

* :visited выбирает посещённые ссылки.

* :active выбирает активные ссылки (кнопка мыши зажата на ссылке).

Пример задания CSS-правил для ссылок:
```css
a:link { ... }
a:visited { ... }
a:hover { ... }
a:active { ... }
```

Обратите внимание на порядок правил. Если их расположить по-другому, то некоторые могут не сработать.

## Псевдокласс :focus

Псевдокласс __:focus__ позволяет выбрать элемент, который в данный момент в фокусе. Например, текстовое поле, в которое установлен курсор, находится в фокусе.

В фокусе могут быть не только текстовые поля. Если вы переключаетесь между элементами веб-страницы с помощью клавиши __tab__, то в фокус будут попадать ссылки.

Пример использования псевдокласса:

```css
input:focus {
  /* стили для поля в фокусе */
}
```

## Селекторы атрибутов

Ранее мы познакомились с атрибутом __class__ и специальными селекторами по классу. Существуют селекторы, которые позволяют выбирать элементы по любым атрибутам.

Чаще всего такие селекторы используются при работе с формами, так как поля форм имеют атрибут __type__ с разными значениями.

Селекторы атрибутов записываются с использованием квадратных скобок: __элемент[атрибут]__. Примеры селекторов:

```css
1. input[checked] { ... }
2. input[type="text"] { ... }
```
Первый селектор выберет поля формы, у которых есть атрибут __checked__, второй селектор выберет поля формы, у которых атрибут __type__ имеет значение __text__.

## Селектор по id

Существует ещё один HTML-атрибут, для которого существует специальный селектор. Этот атрибут __id__ (идентификатор), а селектор записывается с помощью символа __#__, например, __#some-id__.

На значение __id__ распространяются те же ограничения, что и на имя класса. Также __id__ должен быть уникальным на странице.

*Использование селекторов по id при оформлении считается плохой практикой. Существуют редкие исключения из этого правила, например, при оживлении слайдера на чистом CSS.*


## Испытание: Дуэль

```html
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8">
    <title>Испытание. Дуэль</title>
    <link rel="stylesheet" href="style.css">
  </head>
  <body>
    <div class="shooter-1">
      <ul class="target">
        <li>
          <div class="hitbox"></div>
          <div class="lever"><span></span></div>
        </li>
        <li class="miss">
          <div class="hitbox"></div>
          <div class="lever"><span></span></div>
        </li>
        <li class="miss">
          <div class="hitbox"></div>
          <div class="lever"><span></span></div>
        </li>
        <li>
          <div class="hitbox"></div>
          <div class="lever"><span></span></div>
        </li>
        <li class="miss">
          <div class="hitbox"></div>
          <div class="lever"><span></span></div>
        </li>
      </ul>
    </div>
    <div class="shooter-2">
      <ul class="target">
        <li>
          <div class="hitbox"></div>
          <div class="lever"><span></span></div>
        </li>
        <li>
          <div class="hitbox"></div>
          <div class="lever"><span></span></div>
        </li>
        <li>
          <div class="hitbox"></div>
          <div class="lever"><span></span></div>
        </li>
        <li>
          <div class="hitbox"></div>
          <div class="lever"><span></span></div>
        </li>
        <li>
          <div class="hitbox"></div>
          <div class="lever"><span></span></div>
        </li>
      </ul>
    </div>
  </body>
</html>
```

```css
 body {
  width: 280px;
  margin: 0;
  padding: 0;
}

.shooter-1 {
  padding: 55px 0 55px 0;

  background-color: #fcf8e3;
  border-bottom: 1px dashed #cccccc;
}

.shooter-2 {
  padding: 55px 0 55px 0;

  background-color: #d9edf7;
}

.shooter-1 ul, .shooter-2 ul {
  display: flex;
  justify-content: space-between;
  width: 200px;
  height: 25px;
  margin: 0 auto;
  padding: 10px 15px 10px 15px;
  overflow: hidden;

  list-style: none;

  background-color: white;
  border-radius: 2px;
  box-shadow: 0 0 3px rgba(0, 0, 0, 0.5);
}

.shooter-1 li, .shooter-2 li {
  position: relative;

  width: 22px;
  height: 22px;

  font-size: 0;

  background-color: #333333;
  border: 1px solid black;
  border-radius: 50%;
}

.shooter-1 .hitbox, .shooter-2 .hitbox {
  width: 10px;
  height: 10px;
  margin: 6px auto;

  background-color: #999999;
  border-radius: 50%;
}

.shooter-1 .lever, .shooter-2 .lever{
  position: absolute;
  top: -2px;
  left: -2px;

  width: 26px;
  height: 26px;

  background-color: #f5f5f5;
  border-radius: 50%;
  box-shadow: 0 0 2px rgba(0, 0, 0, 0.5);
}

.shooter-1 .lever>span, .shooter-2 span {
  position: absolute;
  top: 12px;
  left: 11px;

  width: 5px;
  height: 25px;

  background-color: #f5f5f5;
  box-shadow: -1px 15px 2px rgba(0, 0, 0, 0.3), 1px 15px 2px rgba(0, 0, 0, 0.3);
}

.shooter-1 .miss .lever{
  display: none;
}

.shooter-2 li:nth-child(1) .lever{
  display: none;
}

.shooter-2 li:nth-child(4) .lever {
  display: none;
}
.shooter-2 li:nth-child(5) .lever {  display: none;
}
```


