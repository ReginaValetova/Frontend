# Селекторы

## Селекторы по тегам

Задавать атрибут __style__ для каждого тега неудобно и долго. Особенно, если тот же результат можно получить с помощью единственного CSS-правила, в котором используется селектор для тега __li__.

С помощью селекторов по именам тегов можно задать стили для всех элементов списка, изображений, абзацев и так далее. Эти селекторы содержат имя тега без символов **<** и **>**. Например:

```css
li {
  /* стили для элементов списка */
}
```

## Селекторы по классам

Класс — это один из атрибутов тегов. Выглядит он вот так:

```css
<li class="first"></li>
```
Этот атрибут особенный, так как в CSS существует возможность выбирать элементы по классу. Делается это с помощью такого селектора: __.имя_класса__. Например:
```css
.first {
  /* стили для класса first */
}
```
## Контекстные селекторы

Селектор может состоять из нескольких частей, разделённых пробелом, например:

```css
p strong { ... }
ul .hit { ... }
.footer .menu a { ... }
```

Такие селекторы называют контекстными или вложенными. Их используют для того, чтобы применить стили к элементу, только если он вложен в нужный элемент.

Например, селектор __.menu__ a сработает для ссылки __a__ только в том случае, если она расположена внутри элемента с классом __.menu__.

Читать их проще всего справа налево:

```css
/* выбрать все теги strong внутри тегов p */
p strong { ... }

/* выбрать все элементы с классом .hit внутри тегов ul */
ul .hit { ... }

/* выбрать все ссылки внутри элементов с классом .menu,
   которые лежат внутри элементов с классом .footer */
.footer .menu a { ... }

```

Таким образом, можно задавать элементам различные стили в зависимости от их контекста. Если ссылка расположена внутри меню, сделать её крупнее, а если внутри основного текста, то задать ей нужный цвет.

## Соседние селекторы

Контекстные селекторы используются для вложенных друг в друга элементов, а соседние — для расположенных рядом.

Например, теги __'li'__ в списке являются соседними по отношению друг к другу и вложенными в тег __'ul'__.

Соседние селекторы записываются с помощью знака __+__, например, __селектор1 + селектор2__. Стили применятся к элементу, подходящему под __селектор2__, только если сразу перед ним расположен элемент, подходящий под __селектор1__.

Пример. Есть два элемента списка:
```css
<li class="hit"></li>
<li class="miss"></li>
```
Селектор __.hit + .miss__ применит стили к элементу с классом __miss__, так как перед ним есть элемент с классом __hit__.

Селектор __.hit + li__ тоже применит стили к элементу с классом __miss__, а селектор __.miss + .hit__ не сработает.

## Дочерние селекторы

Потомком называются любые элементы, расположенные внутри родительского элемента. А дочерними элементами называются ближайшие потомки. Взгляните на пример:

```css
<ul>
  <li><span> ... </span></li>
  <li><span> ... </span></li>
</ul>
```
По отношению к __'ul' 'li'__ являются дочерними элементами и потомками, а __'span'__ — потомки, но не дочерние элементы.

Контекстные селекторы влияют на всех потомков, что не всегда удобно. Иногда необходимо задать стили только для дочерних элементов. Особенно это полезно при работе с многоуровневыми списками.

Для этого существует дочерний селектор, в котором используется символ >. Например: __ul > li__ или __ul > li > span__.

## Псевдоклассы

Псевдоклассы — это дополнения к обычным селекторам, которые делают их ещё точнее и мощнее. Обычный селектор — это снайперский прицел, а с псевдоклассом он становится прибором ночного видения.

Псевдокласс добавляется к селектору c помощью символа __:__, вот так __селектор:псевдокласс__. Например:
```css
a:visited { ... }
li:last-child { ... }
.alert:hover { ... }
```

Знакомство с псевдоклассами мы начнём с __first-child__ и __last-child__.

Псевдокласс __first-child__ позволяет выбрать первый дочерний элемент родителя, а __last-child__ — последний дочерний элемент. Например:

```css
li:last-child { ... }
```
Этот селектор выберет последний элемент списка.

## Псевдокласс :nth-child

С помощью псевдокласса __nth-child__ можно выбирать теги по порядковому номеру, не используя классы. Синтаксис псевдокласса: __селектор:nth-child__(выражение). Выражением может быть число или формула. Например:

```css
1. li:nth-child(2) { ... }
2. li:nth-child(4) { ... }
3. li:nth-child(2n) { ... }
```
Первый селектор выберет второй элемент списка, второй селектор — четвёртый элемент списка, третий селектор — все чётные элемент

## Псевдокласс :hover

Некоторые псевдоклассы позволяют выбирать элементы, с которыми взаимодействует пользователь. Сначала познакомимся с псевдоклассом __:hover__.

Этот псевдокласс позволяет выбрать элемент, когда на него наведён курсор мыши и кнопка мыши не нажата. Примеры:
```css
1. a:hover { ... }
2. tr:hover { ... }
3 .menu-item:hover { ... }
```

Первый селектор выбирает ссылку, второй строку таблицы, третий элемент с классом __menu-item__, но только в том случае, если на них наведён курсор мыши.

Благодаря этому псевдоклассу можно добавлять в интерфейс динамику и интерактивность, так как элементы начинают реагировать на действия пользователя, изменяя свой внешний вид.


## Динамические эффекты с помощью :hover

Интересовались ли вы, как с помощью CSS создаются выпадающие меню?

Львиная доля динамических эффектов, создаваемых с помощью CSS, опираются на несколько псевдоклассов, главный из которых, конечно же, __:hover__. Весь секрет заключается в сочетании контекстных селекторов и псевдоклассов. Посмотрите на пример:

```css
li.top ul.submenu {
  display: none;
}

li.top:hover ul.submenu {
  display: block;
}
```

Первое правило прячет список-подменю. Второе правило гласит: «если на верхний пункт меню, в котором находится подменю, наведут курсор, то надо показать подменю». Вот так всё просто.

Общий принцип такой: родительский элемент реагирует на наведение мыши и изменяет свойства элементов-потомков. То есть всё работает на контекстных селекторах вида __селектор1:hover селектор2__.

## Псевдоклассы :link, :visited и :active

Познакомимся с псевдоклассами для ссылок.

* :link выбирает ещё не посещённые ссылки.

* :visited выбирает посещённые ссылки.

* :active выбирает активные ссылки (кнопка мыши зажата на ссылке).

Пример задания CSS-правил для ссылок:
```css
a:link { ... }
a:visited { ... }
a:hover { ... }
a:active { ... }
```

Обратите внимание на порядок правил. Если их расположить по-другому, то некоторые могут не сработать.